import * as path from 'path';
import * as fs from 'fs-extra';

// Type definitions
export interface ValidationResult {
  isValid: boolean;
  error?: string;
  normalizedName?: string;
}

export interface ModuleNameInput {
  name: string;
}

export interface ModulePathInput {
  moduleName: string;
  baseDir?: string;
}

export interface DirectoryExistsInput {
  dirPath: string;
}

export interface SuccessMessageInput {
  moduleName: string;
  modulePath: string;
}

// New interfaces for file generation
export interface ApiType {
  type: 'crud' | 'custom';
  customNames?: string[];
}

export interface FileGenerationInput {
  moduleName: string;
  modulePath: string;
  apiType: ApiType;
}

export interface GeneratedFile {
  fileName: string;
  filePath: string;
  content: string;
}

export interface ExistingModule {
  moduleName: string;
  modulePath: string;
  existingFiles: string[];
  hasTypes: boolean;
}

export interface ModuleDetectionInput {
  moduleName: string;
  baseDir?: string;
}

/**
 * Validates a module name using functional programming style
 */
export const validateModuleName = ({ name }: ModuleNameInput): ValidationResult => {
  if (!name || typeof name !== 'string') {
    return {
      isValid: false,
      error: 'Module name is required and must be a string'
    };
  }

  const trimmedName = name.trim();

  if (trimmedName.length === 0) {
    return {
      isValid: false,
      error: 'Module name cannot be empty'
    };
  }

  // Check for valid characters (alphanumeric, hyphens, underscores)
  const validNameRegex = /^[a-zA-Z0-9_-]+$/;
  if (!validNameRegex.test(trimmedName)) {
    return {
      isValid: false,
      error: 'Module name can only contain letters, numbers, hyphens, and underscores'
    };
  }

  // Check if name starts with a letter or underscore
  if (!/^[a-zA-Z_]/.test(trimmedName)) {
    return {
      isValid: false,
      error: 'Module name must start with a letter or underscore'
    };
  }

  return {
    isValid: true,
    normalizedName: trimmedName.toLowerCase()
  };
};

/**
 * Generates the target directory path for a module using functional programming style
 */
export const getModulePath = ({ moduleName, baseDir = process.cwd() }: ModulePathInput): string => {
  return path.join(baseDir, 'src', 'apis', moduleName);
};

/**
 * Checks if a directory already exists using functional programming style
 */
export const directoryExists = async ({ dirPath }: DirectoryExistsInput): Promise<boolean> => {
  try {
    const stats = await fs.stat(dirPath);
    return stats.isDirectory();
  } catch (error: any) {
    if (error.code === 'ENOENT') {
      return false;
    }
    throw error;
  }
};

/**
 * Gets the list of subdirectories to create for an API module using functional programming style
 */
export const getModuleSubdirectories = (): string[] => {
  return [
    'controllers',
    'handlers',
    'schema',
    'types',
    'repository',
    'validators'
  ];
};

/**
 * Formats a success message with the created structure using functional programming style
 */
export const formatSuccessMessage = ({ moduleName, modulePath }: SuccessMessageInput): string => {
  const subdirs = getModuleSubdirectories();
  const structure = subdirs.map(dir => `  â”œâ”€â”€ ${dir}/`).join('\n');

  return `
âœ… Successfully created API module structure for "${moduleName}"

ðŸ“ Created directory structure:
${modulePath}/
${structure}

ðŸš€ Your API module is ready for development!
`;
};

/**
 * Gets the list of CRUD operation file names for a module
 */
export const getCrudFileNames = ({ moduleName }: { moduleName: string }): string[] => {
  return [
    `create.${moduleName}.ts`,
    `get.${moduleName}.ts`,
    `list.${moduleName}.ts`,
    `delete.${moduleName}.ts`,
    `update.${moduleName}.ts`
  ];
};

/**
 * Gets custom API file names for a module
 */
export const getCustomFileNames = ({
  customNames,
  moduleName
}: {
  customNames: string[];
  moduleName: string;
}): string[] => {
  return customNames.map(customName => `${customName}.${moduleName}.ts`);
};

/**
 * Generates TypeScript file content for CRUD operations
 */
export const generateCrudFileContent = ({
  operation,
  moduleName
}: {
  operation: string;
  moduleName: string;
}): string => {
  const capitalizedModule = moduleName.charAt(0).toUpperCase() + moduleName.slice(1);
  const capitalizedOperation = operation.charAt(0).toUpperCase() + operation.slice(1);

  return `// ${capitalizedOperation} ${capitalizedModule} Type Definitions
// Generated by node-apis CLI

export interface ${capitalizedOperation}${capitalizedModule}Request {
  // TODO: Define request interface for ${operation} ${moduleName}
}

export interface ${capitalizedOperation}${capitalizedModule}Response {
  // TODO: Define response interface for ${operation} ${moduleName}
}

export interface ${capitalizedOperation}${capitalizedModule}Params {
  // TODO: Define params interface for ${operation} ${moduleName}
}

// Example usage:
// import { ${capitalizedOperation}${capitalizedModule}Request, ${capitalizedOperation}${capitalizedModule}Response } from './types/${operation}.${moduleName}';
`;
};

/**
 * Generates TypeScript file content for custom API operations
 */
export const generateCustomFileContent = ({
  customName,
  moduleName
}: {
  customName: string;
  moduleName: string;
}): string => {
  const capitalizedModule = moduleName.charAt(0).toUpperCase() + moduleName.slice(1);
  const capitalizedCustom = customName.charAt(0).toUpperCase() + customName.slice(1);

  return `// ${capitalizedCustom} ${capitalizedModule} Type Definitions
// Generated by node-apis CLI

export interface ${capitalizedCustom}${capitalizedModule}Request {
  // TODO: Define request interface for ${customName} ${moduleName}
}

export interface ${capitalizedCustom}${capitalizedModule}Response {
  // TODO: Define response interface for ${customName} ${moduleName}
}

export interface ${capitalizedCustom}${capitalizedModule}Params {
  // TODO: Define params interface for ${customName} ${moduleName}
}

// Example usage:
// import { ${capitalizedCustom}${capitalizedModule}Request, ${capitalizedCustom}${capitalizedModule}Response } from './types/${customName}.${moduleName}';
`;
};

/**
 * Detects if a module already exists and returns information about it
 */
export const detectExistingModule = async ({
  moduleName,
  baseDir = process.cwd()
}: ModuleDetectionInput): Promise<ExistingModule | null> => {
  const modulePath = getModulePath({ moduleName, baseDir });
  const exists = await directoryExists({ dirPath: modulePath });

  if (!exists) {
    return null;
  }

  const typesDir = path.join(modulePath, 'types');
  const hasTypes = await directoryExists({ dirPath: typesDir });

  let existingFiles: string[] = [];
  if (hasTypes) {
    try {
      const files = await fs.readdir(typesDir);
      existingFiles = files.filter(file => file.endsWith('.ts'));
    } catch (error) {
      // Directory exists but can't read it
      existingFiles = [];
    }
  }

  return {
    moduleName,
    modulePath,
    existingFiles,
    hasTypes
  };
};

/**
 * Gets a list of existing modules in the project
 */
export const getExistingModules = async ({ baseDir = process.cwd() }: { baseDir?: string } = {}): Promise<string[]> => {
  const apisDir = path.join(baseDir, 'src', 'apis');
  const exists = await directoryExists({ dirPath: apisDir });

  if (!exists) {
    return [];
  }

  try {
    const entries = await fs.readdir(apisDir, { withFileTypes: true });
    return entries
      .filter(entry => entry.isDirectory())
      .map(entry => entry.name);
  } catch (error) {
    return [];
  }
};
